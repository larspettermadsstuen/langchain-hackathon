# generated by datamodel-codegen:
#   filename:  dbt-jsonschema_main_schemas_dbt_yml_files.json
#   timestamp: 2023-09-07T11:26:22+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, Extra, Field, constr, RootModel


class Column(BaseModel):
    class Config:
        arbitrary_types_allowed=True
        extra = Extra.forbid

    name: str
    description: Optional[str] = None
    data_type: Optional[str] = None


class Docs(BaseModel):
    show: bool


class Type(Enum):
    dashboard = 'dashboard'
    notebook = 'notebook'
    analysis = 'analysis'
    ml = 'ml'
    application = 'application'


class Maturity(Enum):
    high = 'high'
    medium = 'medium'
    low = 'low'


class Owner(BaseModel):
    class Config:
        arbitrary_types_allowed=True
        extra = Extra.forbid

    name: Optional[str] = None
    email: str


class Owner1(BaseModel):
    class Config:
        arbitrary_types_allowed=True
        extra = Extra.forbid

    name: Optional[str] = None
    email: Optional[str] = None


class Group(BaseModel):
    class Config:
        arbitrary_types_allowed=True
        extra = Extra.forbid

    name: str
    owner: Owner1


class Argument(BaseModel):
    class Config:
        arbitrary_types_allowed=True
        extra = Extra.forbid

    name: str
    type: Optional[str] = None
    description: Optional[str] = None


class Docs1(BaseModel):
    show: Optional[bool] = None


class Macro(BaseModel):
    class Config:
        arbitrary_types_allowed=True
        extra = Extra.forbid

    name: str
    arguments: Optional[List[Argument]] = None
    description: Optional[str] = None
    docs: Optional[Docs1] = None


class Filter(BaseModel):
    class Config:
        arbitrary_types_allowed=True
        extra = Extra.forbid

    field: str
    operator: str
    value: str


class Period(Enum):
    day = 'day'
    week = 'week'
    month = 'month'
    year = 'year'


class Window(BaseModel):
    count: Optional[int] = None
    period: Optional[Period] = None


class Access(Enum):
    private = 'private'
    protected = 'protected'
    public = 'public'


ArrayOfStrings = RootModel[List[str]]


class GrantAccessToItem(BaseModel):
    class Config:
        arbitrary_types_allowed=True
        extra = Extra.forbid

    database: str
    project: str

StringOrArrayOfStrings = RootModel[Union[str, ArrayOfStrings]]


class Period1(Enum):
    minute = 'minute'
    hour = 'hour'
    day = 'day'


JinjaString = RootModel[str]
#class JinjaString(BaseModel):
#    pass
    #__root__: constr(regex=r'\{\{.*\}\}')


class SeverityEnum(Enum):
    warn = 'warn'
    error = 'error'

NumberOrJinjaString = RootModel[Union[JinjaString, float]]
#class NumberOrJinjaString(BaseModel):
#    __root__: Union[JinjaString, float]


class Config(BaseModel):
    class Config:
        arbitrary_types_allowed=True
        extra = Extra.forbid

    tags: Optional[StringOrArrayOfStrings] = None


class Analyse(BaseModel):
    name: str
    columns: Optional[List[Column]] = None
    config: Optional[Config] = None
    description: Optional[str] = None
    docs: Optional[Docs] = None


class Exposure(BaseModel):
    name: str
    label: Optional[str] = None
    type: Type
    depends_on: List[str]
    description: Optional[str] = None
    maturity: Optional[Maturity] = None
    meta: Optional[Dict[str, Any]] = None
    owner: Owner
    tags: Optional[StringOrArrayOfStrings] = None
    url: Optional[str] = None

BooleanOrJinjaString = RootModel[Union[JinjaString, bool]]
#class BooleanOrJinjaString(BaseModel):
#    __root__: Union[JinjaString, bool]


class Constraint(BaseModel):
    columns: Optional[StringOrArrayOfStrings] = None
    expression: Optional[str] = None
    name: Optional[str] = None
    type: str
    warn_unenforced: Optional[BooleanOrJinjaString] = None
    warn_unsupported: Optional[BooleanOrJinjaString] = None

Constraints = RootModel[List[Constraint]]
#class Constraints(BaseModel):
#    __root__: List[Constraint]


class IncludeExclude(BaseModel):
    include: Optional[StringOrArrayOfStrings] = None
    exclude: Optional[StringOrArrayOfStrings] = None


class Contract(BaseModel):
    enforced: Optional[BooleanOrJinjaString] = None


class ModelConfigs(BaseModel):
    contract: Optional[Contract] = None
    file_format: Optional[str] = None
    grant_access_to: Optional[List[GrantAccessToItem]] = Field(
        None,
        description='Configuration, specific to BigQuery adapter, used to setup authorized views.',
        title='Authorized views',
    )
    hours_to_expiration: Optional[float] = Field(
        None,
        description='Configuration specific to BigQuery adapter used to set an expiration delay (in hours) to a table.',
    )
    # kms_key_name: Optional[
    #     constr(
    #         regex=r'projects/[a-zA-Z0-9_-]*/locations/[a-zA-Z0-9_-]*/keyRings/.*/cryptoKeys/.*'
    #     )
    # ] = Field(
    #     None,
    #     description='Configuration of the KMS key name, specific to BigQuery adapter.',
    # )
    # labels: Optional[
    #     Dict[
    #         constr(regex=r'^[a-z][a-z0-9_-]{0,62}$'),
    #         constr(regex=r'^[a-z0-9_-]{0,63}$'),
    #     ]
    # ] = Field(
    #     None,
    #     description='Configuration specific to BigQuery adapter used to add labels and tags to tables/views created by dbt.',
    #     title='Label configs',
    # )
    location: Optional[str] = None
    materialized: Optional[str] = None
    sql_header: Optional[str] = None


class PersistDocsConfig(BaseModel):
    class Config:
        arbitrary_types_allowed=True
        extra = Extra.forbid

    columns: Optional[BooleanOrJinjaString] = Field(
        default_factory=lambda: BooleanOrJinjaString.parse_obj(True)
    )
    relation: Optional[BooleanOrJinjaString] = Field(
        default_factory=lambda: BooleanOrJinjaString.parse_obj(True)
    )


class FreshnessRules(BaseModel):
    class Config:
        arbitrary_types_allowed=True
        extra = Extra.forbid

    count: NumberOrJinjaString
    period: Period1


class TestConfigs(BaseModel):
    alias: Optional[str] = Field(
        None, description='Only relevant when `store_failures` is true'
    )
    database: Optional[str] = Field(
        None, description='Only relevant when `store_failures` is true'
    )
    enabled: Optional[BooleanOrJinjaString] = None
    error_if: Optional[str] = None
    fail_calc: Optional[str] = None
    limit: Optional[float] = None
    schema_: Optional[str] = Field(
        None, alias='schema', description='Only relevant when `store_failures` is true'
    )
    severity: Optional[Union[JinjaString, SeverityEnum]] = None
    store_failures: Optional[BooleanOrJinjaString] = None
    tags: Optional[StringOrArrayOfStrings] = None
    warn_if: Optional[str] = None


class Config1(BaseModel):
    enabled: Optional[BooleanOrJinjaString] = None
    treat_null_values_as_zero: Optional[BooleanOrJinjaString] = None
    group: Optional[str] = None


class Metric(BaseModel):
    class Config:
        arbitrary_types_allowed=True
        extra = Extra.forbid

    config: Optional[Config1] = None
    calculation_method: str
    description: Optional[str] = None
    dimensions: Optional[ArrayOfStrings] = None
    expression: str
    filters: Optional[List[Filter]] = None
    label: str
    meta: Optional[Dict[str, Any]] = None
    model: Optional[str] = "ref('')"
    name: str
    time_grains: Optional[ArrayOfStrings] = None
    timestamp: Optional[str] = None
    window: Optional[Window] = None


class Config2(BaseModel):
    column_types: Optional[Dict[str, Any]] = None
    copy_grants: Optional[BooleanOrJinjaString] = None
    database: Optional[str] = None
    enabled: Optional[BooleanOrJinjaString] = None
    quote_columns: Optional[BooleanOrJinjaString] = None
    schema_: Optional[str] = Field(None, alias='schema')


class Config3(BaseModel):
    alias: Optional[str] = None
    check_cols: Optional[StringOrArrayOfStrings] = None
    enabled: Optional[BooleanOrJinjaString] = None
    grants: Optional[Dict[str, Any]] = None
    persist_docs: Optional[PersistDocsConfig] = None
    post_hook: Optional[ArrayOfStrings] = Field(None, alias='post-hook')
    pre_hook: Optional[ArrayOfStrings] = Field(None, alias='pre-hook')
    quote_columns: Optional[BooleanOrJinjaString] = None
    strategy: Optional[str] = None
    tags: Optional[StringOrArrayOfStrings] = None
    target_database: Optional[str] = None
    target_schema: Optional[str] = None
    unique_key: Optional[StringOrArrayOfStrings] = None
    updated_at: Optional[str] = None


class Quoting(BaseModel):
    class Config:
        arbitrary_types_allowed=True
        extra = Extra.forbid

    database: Optional[BooleanOrJinjaString] = None
    identifier: Optional[BooleanOrJinjaString] = None
    schema_: Optional[BooleanOrJinjaString] = Field(None, alias='schema')


class FreshnessDefinitionItem(BaseModel):
    class Config:
        arbitrary_types_allowed=True
        extra = Extra.forbid

    error_after: Optional[FreshnessRules] = None
    filter: Optional[str] = None
    warn_after: Optional[FreshnessRules] = None

FreshnessDefinition = RootModel[Union[FreshnessDefinitionItem, Any]]
#class FreshnessDefinition(BaseModel):
#    __root__: Union[FreshnessDefinitionItem, Any]


class Relationships(BaseModel):
    name: Optional[str] = None
    config: Optional[TestConfigs] = None
    field: str = Field(
        ..., description='The foreign key column', title='Relationships: Field'
    )
    to: str = Field(
        ..., examples=["ref('parent_model')", "source('parent_schema', 'parent_table')"]
    )
    where: Optional[str] = None


class Test(BaseModel):
    relationships: Optional[Relationships] = None


class AcceptedValues(BaseModel):
    name: Optional[str] = None
    config: Optional[TestConfigs] = None
    quote: Optional[bool] = None
    values: List[str]
    where: Optional[str] = None


class Test1(BaseModel):
    accepted_values: Optional[AcceptedValues] = None


class NotNull(BaseModel):
    name: Optional[str] = None
    config: Optional[TestConfigs] = None
    where: Optional[str] = None


class Test2(BaseModel):
    not_null: Optional[NotNull] = None


class Unique(BaseModel):
    name: Optional[str] = None
    config: Optional[TestConfigs] = None
    where: Optional[str] = None


class Test3(BaseModel):
    unique: Optional[Unique] = None

class Tests: RootModel[Union[str, Test, Test1, Test2, Test3, Any]]
#class Tests(BaseModel):
#    __root__: Union[str, Test, Test1, Test2, Test3]


class ColumnProperties(BaseModel):
    class Config:
        arbitrary_types_allowed=True
        extra = Extra.forbid

    name: str
    constraints: Optional[Constraints] = None
    data_type: Optional[str] = None
    description: Optional[str] = None
    meta: Optional[Dict[str, Any]] = None
    policy_tags: Optional[List[str]] = Field(
        None,
        description='Configurations, specific to BigQuery adapter, used to set policy tags on specific columns, enabling column-level security. Only relevant when `persist_docs.columns` is true.',
        title='Policy tags',
    )
    quote: Optional[BooleanOrJinjaString] = None
    tests: Optional[List[Any]] = None
    tags: Optional[StringOrArrayOfStrings] = None


class Version(BaseModel):
    v: float
    config: Optional[ModelConfigs] = None
    columns: Optional[List[Union[IncludeExclude, ColumnProperties]]] = None


class Model(BaseModel):
    class Config:
        arbitrary_types_allowed=True
        extra = Extra.forbid

    name: str
    access: Optional[Access] = None
    columns: Optional[List[ColumnProperties]] = None
    config: Optional[ModelConfigs] = None
    constraints: Optional[Constraints] = None
    description: Optional[str] = None
    docs: Optional[Docs1] = None
    group: Optional[str] = None
    latest_version: Optional[float] = None
    meta: Optional[Dict[str, Any]] = None
    tests: Optional[List[Any]] = None
    versions: Optional[List[Version]] = None


class Seed(BaseModel):
    class Config:
        arbitrary_types_allowed=True
        extra = Extra.forbid

    name: str
    columns: Optional[List[ColumnProperties]] = None
    config: Optional[Config2] = None
    description: Optional[str] = None
    docs: Optional[Docs1] = None
    tests: Optional[List[Any]] = None


class Snapshot(BaseModel):
    class Config:
        arbitrary_types_allowed=True
        extra = Extra.forbid

    name: str
    columns: Optional[List[ColumnProperties]] = None
    config: Optional[Config3] = None
    description: Optional[str] = None
    docs: Optional[Docs1] = None
    meta: Optional[Dict[str, Any]] = None
    tests: Optional[List[Any]] = None


class Table(BaseModel):
    class Config:
        arbitrary_types_allowed=True
        extra = Extra.forbid

    name: str = Field(
        ...,
        description='How you will identify the table in {{ source() }} calls. Unless `identifier` is also set, this will be the name of the table in the database.',
        title='Name',
    )
    columns: Optional[List[ColumnProperties]] = None
    description: Optional[str] = None
    external: Optional[Dict[str, Any]] = None
    freshness: Optional[FreshnessDefinition] = None
    identifier: Optional[str] = Field(
        None,
        description='The table name as stored in the database. Only needed if you want to give the source a different name than what exists in the database (otherwise `name` is used by default)',
        title='Identifier',
    )
    loaded_at_field: Optional[str] = Field(
        None,
        description='Which column to check during data freshness tests. Only needed if the table has a different loaded_at_field to the one defined on the source overall.',
    )
    loader: Optional[str] = None
    meta: Optional[Dict[str, Any]] = None
    quoting: Optional[Quoting] = None
    tags: Optional[StringOrArrayOfStrings] = None
    tests: Optional[List[Any]] = None


class Source(BaseModel):
    class Config:
        arbitrary_types_allowed=True
    name: str = Field(
        ...,
        description='How you will identify the schema in {{ source() }} calls. Unless `schema` is also set, this will be the name of the schema in the database.',
    )
    config: Optional[Dict[str, Any]] = None
    database: Optional[str] = None
    description: Optional[str] = None
    freshness: Optional[FreshnessDefinition] = None
    loaded_at_field: Optional[str] = None
    loader: Optional[str] = None
    meta: Optional[Dict[str, Any]] = None
    overrides: Optional[str] = Field(
        None,
        description='The name of another package installed in your project. If that package has a source with the same name as this one, its properties will be applied on top of the base properties of the overridden source. https://docs.getdbt.com/reference/resource-properties/overrides',
        title='Package to Override',
    )
    quoting: Optional[Quoting] = None
    schema_: Optional[str] = Field(
        None,
        alias='schema',
        description='The schema name as stored in the database. Only needed if you want to use a different `name` than what exists in the database (otherwise `name` is used by default)',
    )
    tables: Optional[List[Table]] = None
    tags: Optional[StringOrArrayOfStrings] = None
    tests: Optional[List[Any]] = None


class DbtYmlFiles(BaseModel):
    class Config:
        arbitrary_types_allowed=True
        extra = Extra.forbid

    analyses: Optional[List[Analyse]] = None
    exposures: Optional[List[Exposure]] = None
    groups: Optional[List[Group]] = None
    macros: Optional[List[Macro]] = None
    metrics: Optional[List[Metric]] = None
    models: Optional[List[Model]] = None
    seeds: Optional[List[Seed]] = None
    snapshots: Optional[List[Snapshot]] = None
    sources: Optional[List[Source]] = None
